# research2020
ORの実装・信頼値測定についてのメモ
## シミュレーションにおける設定について
## To do
## パケット送受信に関して
- トポロジ生成に関して
    - edgeの設定
        - edgeを手動で設定(現時点)
        - リンクの通信成功率を重みとして設定
        - ノード0，ノードn(最終的なノード数)が接続になるようにする
        - 信頼値測定が行えるようにするにはトポロジ生成も少し工夫しなければならない？
- ノードの設定
    - 接続しているノードの情報を与える
    - 最終的には座標からトポロジを生成したい
- パケットの送信
    - 最初にETXに応じて送信元から1ホップの送信優先度を決定する
        - ETXについてはダイクストラ法で計算する
        - もっとも良い経路がETXを計算した時点で確定するのではないか？
        - priority_queueをノードごとに持たせる
    - edgeがあるノードにブロードキャスト
        - 転送優先度の高いノードがパケットを転送する
    - 転送優先度の決定について
        - 送信元から1hopの場合とそうでない場合に分ける？
    - 信頼値が閾値以下のノードには送信しない(後で)
    - キューのパケットをコピーする必要がある
        - 例えばエッジが2つあったとき112233みたいにコピーして送信するため
        - 実際には，123123の順に送信
    - パケットのドロップについて(実例で考える)
        - 優先度がもっとも高いノードが送信する
        - 送信に失敗したパケットを送信する
        - 送信に失敗していないパケットは送信しない->ドロップする
        - 
    - パケットが不達かどうかは気にせず，例えば100回送信元がブロードキャストしたらそれ以上のブロードキャストは行わない
- パケットの受信
    - 受信時に信頼値を見る？
    - すでに受信していたらdropする
- パケットについて
    - uidで識別する形で行う
- 2ホップ以上先のノードがパケットを受信する場合
    - TBD
## ノード信頼値測定について
- 直接的な観察
    - リンクのある1ホップノードのパケットのドロップなどの挙動を観察
    - エッジのあるノードを観察する
    - 逆方向へ通知するスキーム
- 間接的な観察
    - リンクのある1ホップノードに直接観察可能なノードの挙動を観察させる
    - リンクがある1ホップノードかつ観察対象のノードとリンクがある=>リンクのある1ホップノードから直接的な信頼値を収集
    - 「近傍ノードに観察させる」部分が難しそう
- 最終的な信頼値の決定方法
    - 重みづけ
- 提案手法の部分について
    - 後で

## 評価について
- 悪意のあるノードと検知率(誤検知率も？)
- 悪意のあるノードとパケット配送率の関係
- パケットをドロップする確率と検出率との関係？
    - グレーホール攻撃の考察もできそう
- ////////////以下はできたら//////////////
    - 悪意のあるノードとルーチングコストの関係
        - ルーチングコスト:各ノードと固定宛先へのORの期待コスト(ETXなど)
    - スループット(クロックを計算すればできる)
        - **正確な** スループットの計算はちょっと難しい？

## 参考にしたサイト・論文等(今までのやつもまとめる)
- 実装について
    - [Link Probability Based Opportunistic Routing Metric in Wireless Network](https://ieeexplore.ieee.org/document/4797138)
    - [DFS (深さ優先探索) 超入門！ 〜 グラフ・アルゴリズムの世界への入口 〜【前編】](https://qiita.com/drken/items/4a7869c5e304883f539b)
    - [DFS (深さ優先探索) 超入門！ 〜 グラフ・アルゴリズムの世界への入口 〜【後編】](https://qiita.com/drken/items/a803d4fc4a727e02f7ba#4-%E3%82%B0%E3%83%A9%E3%83%95%E4%B8%8A%E3%81%AE%E6%A7%98%E3%80%85%E3%81%AA%E4%BE%8B%E9%A1%8C)
    - [ダイクストラ法による単一始点最短経路を求めるアルゴリズム](https://algo-logic.info/dijkstra/)
    - [お手軽 乱数実装【C++11】](https://qiita.com/Gaccho/items/dc312fb5a056505f0a9f)
    - [BFS (幅優先探索) 超入門！ 〜 キューを鮮やかに使いこなす 〜](https://qiita.com/drken/items/996d80bcae64649a6580)
    - [C, C++でのファイル入力をまとめてみたよ](https://qiita.com/Reed_X1319RAY/items/098596cda78e9c1a6bad)
- その他
    - [uniform_real_distribution](https://cpprefjp.github.io/reference/random/uniform_real_distribution.html)
    - [cpprefjp - C++日本語リファレンス](https://cpprefjp.github.io/)
    - [グラフ理論(北海道大学)](https://ocw.hokudai.ac.jp/wp-content/uploads/2016/01/GraphTheory-2007-Note-all.pdf)
    - [グラフ探索アルゴリズムとその応用](https://www.ioi-jp.org/camp/2011/hosaka-graph.pdf)
        - 隣接リストなどについて
    - [グラフ描画用のツール](https://kyopro.hateblo.jp/entry/2018/04/26/204335)
## その他事項・疑問・メモ
- 攻撃ノードは通信成功率を0とするとETXが無限になってゼロ除算が発生する
    - 仮の値をセットする？
    - リンクの信頼性ではないのでカット
- 乱数について
    - 初期値はランダムに与えている
    - 乱数はメルセンヌ・ツイスタを使用している
    - パケットの送信成功、失敗はベルヌーイ分布に従う
    - double型の乱数はuniform_real_distributionによって取得
        - 指定された範囲の値が等確率で発生するよう離散分布
    - [参考](https://cpprefjp.github.io/reference/random/uniform_real_distribution.html)
- すべてパケットが到着するまで待つと，パケット配送率が100パーセントになる(当たり前)
<!--
- 信頼値の更新
    - 100ごとにインターバルとかでも良いかも
    - パケットが100到達したごとに更新
-->
- ExOR
    - バッチで送信している(現状だとパケット1こ)
- 深さ優先探索
    - ループがあっても可
- ETX
    - グローバル変数化してetxを求める？
    - 宛先が見つかるまで探索
    - ダイクストラ法を使って求めた
- 送信中止
- 重複パケットを減らしたい
    - 最初からベストなルートをある程度選んでおけば減らせる？
- 2ホップ以降の優先度の決定について
    - 中継ノードが転送優先度を決めるようにしたい
    - あらかじめ計算しておく
- BFS
    - hop数を取得するのに用いる
- routing1からの変更
    - SendlessとSendHighestを変更
## 実装に関するTo do とメモ
- To do(12/8)
    <!--
    - 理論計算
        - 特定のトポロジーを作って試す
    -->
    - 送受信の分離
        - 正しい引数さえ与えれば簡単にできそう
            - Highestとlowerの場合で異なるので注意
        - そこで下に書いているようなことをやればラウンドの定義は容易になるのではないか
    - トポロジのランダム生成
        - ~~ノード数を増やす~~
        - 通信成功率の設定
    - 攻撃の実装
        - 送信の関数のところでやる？
        - for文が増える::ちょっと面倒
        - 完全に宛先までのルートが遮断される場合は棄却する::ダメかも
        - 受信に失敗した場合...betaのカウントを増やす
    - 信頼値測定の実装
        - dtv...エッジのあるノードを観察
            - カウントにラウンドをもたせる必要がある
        - itv...1hopノード内で観察，あるノードから1hopノードは互いに通信できると仮定
        - 悪意のあるノードにはパケットを送らないようにする仕組みが必要
    - 時系列っぽいもの
        - ラウンドの更新を行うタイミングをどこにするか
        - スレッドでやってないので，送信元がnパケットを送信したらなどは不可
        - 宛先がnパケットを受信したらでやる（ブロードキャストのfor文の中には書きたくない）
            - 受信を関数にする
            - 分ける
        - 「宛先がnパケットを受信した」の部分はrecvmapで判別
        - ホップ数のfor文で回していたらラウンド数の受信を余裕で超えそう
        - ちょうどn個受信したみたいな仕組みを作るのは難しいかもしれない
        - 宛先の受信のたびに調べる（非効率な計算）
        - 
        - 
    - ルートを求める関数を作る

- 不具合
    - 優先度がもっとも高いノードが送信するとき，重複を避けないケース

